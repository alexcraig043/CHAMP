#' Get a collection of partitions to run through CHAMP (`get_partitions`)
#'
#' @description The `get_partitions` function is a wrapper around other
#'   CHAMP_Map_scripts helper functions to gather a collection of partitions
#'   using igraph's cluster_leiden for maximizing modularity with a resolution
#'   parameter.
#'
#' @param network The network to be clustered (community detection)
#' @param gamma_range The range of resolution parameters gamma used (default from 0 to 2)
#' @param n_runs The number of cluster_leiden() runs to be attempted (default = 100)
#' @param n_iterations Parameter to be passed to cluster_leiden (default = 2)
#' @param seed Optional random seed for reproducing pseudo-random results
#'
#' @export
#'
#' Coded in parts by Rachel Matthew, Ryan Rebne, Ava Scharfstein and PJM.

get_partitions <- function( network, 
                            gamma_range=c(0,2), 
                            n_runs=100, 
                            n_iterations=2, #parameter for cluster_leiden
                            seed=NULL){
  
  # If seed defined, use it to set the random seed for reproducibility
  if (!is.null(seed)) {set.seed(seed)}
  
  # If gamma_range has more than two values, treat as a list of desired gamma
  # resolution parameter values. Otherwise, generate uniform random collection
  # of gamma values between the min (>=0) and max (>=1) value. If there is only one value in
  # gamma_range, treat it as the max value and set the min to zero.
  if (length(gamma_range)<=2) {
    gamma = runif(n_runs,max(min(gamma_range),0),max(gamma_range,1))
  } else {gamma = gamma_range}
  #print(gamma)
  
  # Call cluster_leiden multiple times, saving results to partitions
  nc <- vector("numeric",length(gamma))
  partitions <- list() 
  for (i in 1:length(gamma)){
    gc <- cluster_leiden(network, objective_function = "modularity",
                         resolution_parameter = gamma[i], 
                         n_iterations = n_iterations)
    gc$gamma <- gamma[i] 
    # cluster number 
    cn <- length(gc)
    cur <- partitions[cn] 
    # if there are no current partitions for this cn
    if (is.na(cur) || is.null(cur[[1]])) {
      partitions[[cn]] <- list(gc) 
    } else {
      cur <- partitions[[cn]] 
      partitions[[cn]][[length(cur)+1]] <- gc
    }
    nc[i] <- cn 
    #partitions[[cn]]
  }
  
  # unique_partitions filters out duplicate partitions
  partitions <- unique_partitions(partitions)
  
  # best_partitions processes the output of unique_partitions to format it
  # appropriately for the following steps and removes partitions that were only
  # generated less than min times (which we take as min=1)
  partitions <- best_partitions(partitions$count, partitions$partitions, min=1)
  
  # Save gamma min & max used so they can be used in CHAMP.R
  partitions$gamma_min <- min(gamma_range)
  partitions$gamma_max <- max(gamma_range)
  
  print(paste(length(partitions$partitions),
              "unique partitions generated by cluster_leiden()"))
  return(partitions)
}
