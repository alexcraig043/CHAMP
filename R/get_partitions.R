#' Get a collection of partitions to run through CHAMP (`get_partitions`)
#'
#' @description The `get_partitions` function is a wrapper around other
#'   CHAMP_Map_scripts helper functions to gather a collection of partitions
#'   using igraph's cluster_leiden for maximizing modularity with a resolution
#'   parameter.
#'
#' @param network The network to be clustered (community detection).
#' @param gamma_range The range of resolution parameters gamma used (default from 0 to 2).
#' @param n_runs The number of cluster_leiden() runs to be attempted (default = 100).
#' @param n_iterations Parameter to be passed to cluster_leiden (default = 2).
#' @param seed Optional random seed for reproducing pseudo-random results.
#' @export
#' @return A list containing unique partitions generated by `cluster_leiden()`.
#' Coded in parts by Rachel Matthew, Ryan Rebne, Ava Scharfstein, and PJM.
get_partitions <- function(network,
                           gamma_range = c(0, 2),
                           n_runs = 100,
                           n_iterations = 2, # parameter for cluster_leiden
                           seed = NULL) {
  # If seed defined, use it to set the random seed for reproducibility
  if (!is.null(seed)) {
    set.seed(seed)
  }

  # Handle gamma_range input
  if (length(gamma_range) <= 2) {
    gamma <- runif(n_runs, max(min(gamma_range), 0), max(gamma_range, 1))
  } else {
    gamma <- gamma_range
  }

  partitions <- list()
  nc <- numeric(length(gamma))

  # Call cluster_leiden multiple times, saving results to partitions
  for (i in seq_along(gamma)) {
    gc <- cluster_leiden(network,
      objective_function = "modularity",
      resolution_parameter = gamma[i],
      n_iterations = n_iterations
    )
    gc$gamma <- gamma[i]

    cn <- length(gc)
    current_partitions <- partitions[cn]

    # If there are no current partitions for this cn
    if (is.na(current_partitions) || is.null(current_partitions[[1]])) {
      partitions[[cn]] <- list(gc)
    } else {
      current_partitions <- partitions[[cn]]
      partitions[[cn]][[length(current_partitions) + 1]] <- gc
    }

    nc[i] <- cn
  }

  partitions <- unique_partitions(partitions)
  partitions <- best_partitions(partitions$count, partitions$partitions, min = 1)

  partitions$gamma_min <- min(gamma_range)
  partitions$gamma_max <- max(gamma_range)

  message(paste(length(partitions$partitions), "unique partitions generated by cluster_leiden()"))
  return(partitions)
}
